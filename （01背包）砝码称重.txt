你有一架天平和 N 个砝码，这 N 个砝码重量依次是 W1,W2,⋅⋅⋅,WN。

请你计算一共可以称出多少种不同的正整数重量？

注意砝码可以放在天平两边。
输入格式

输入的第一行包含一个整数 N

。

第二行包含 N
个整数：W1,W2,W3,⋅⋅⋅,WN

输出格式

输出一个整数代表答案。
数据范围

对于 50%
的评测用例，1≤N≤15。
对于所有评测用例，1≤N≤100，N 个砝码总重不超过 1e5。

样例输入
3
1 4 6


样例输出
10



#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;
//const int Max = 2e5 + 5;
//const int N = 100000;
//int dp[Max];
//int ls[Max];
////思路一：滚动数组，压缩空间
//// 注意：你能凑出来6，就能凑出来-6，
////单看运行完一轮之后，结果其实是对称的
//int main()
//{
//	int n, a, t1, t2; 
//	cin >> n;
//	dp[100000] = 1;
//	while(n--){
//		cin >> a;
//		int g = 0;
//		for (int j = 0; j <= 200000; j++){
//			if (dp[j] >= 1){
//				ls[++g] = (j + a);
//				ls[++g] = (j - a);
//				
//			}
//		}
//		for (int j = 1; j <= g; j++){
//			dp[ls[j]]++;
//		}
//	}
//	int ans = -1;
//
//	for (int i = 100000; i <= 200000; i++)if (dp[i]) ans++;
//	cout << ans;
//}



//思路二：常规dp，但可以优化很多
// 
//其时当发现一个重量可以得负数，再和以后的状态做加减转化时，正数减去也能代表负数，
//如 有砝码 2 1 3
//前俩可以拼凑出的状态 1 2 3 - 1，
//3 + （ - 1）和 3 - 1 效果是一样的，所以负的重量状态抛弃掉最后结果也是不变的
const int MAX = 2e5 + 5;
const int N = 1e5;
bool dp[105][MAX];
int main()
{
	int n;  cin >> n;
	dp[0][0] = 1;
	for (int i = 1; i <= n; i++) {
		int a;  cin >> a;
		for (int j = 0; j <= N; j++) {
			if (dp[i-1][j]) {
				dp[i][j] = 1;
				dp[i][j + a] = 1;
				dp[i][abs(j - a)] = 1;
			}
		}
	}
	int ans = 0;
	for (int i = 1; i <= N; i++) if (dp[n][i]) ans++;
	cout << ans;
}