honoka 有一个只有两个键的键盘。

题目描述
一天，她打出了一个只有这两个字符的字符串。当这个字符串里含有 VK 这个字符串的时候，honoka 就特别喜欢这个字符串。所以，她想改变至多一个字符（或者不做任何改变）来最大化这个字符串内 VK 出现的次数。给出原来的字符串，请计算她最多能使这个字符串内出现多少次 VK（只有当 V 和 K 正好相邻时，我们认为出现了 VK。）

输入格式
第一行给出一个数字 nn，代表字符串的长度。

第二行给出一个字符串 ss。

输出格式
第一行输出一个整数代表所求答案。

输入输出样例
输入 #1复制
2
VK
输出 #1复制
1
输入 #2复制
2
VV
输出 #2复制
1
输入 #3复制
1
V
输出 #3复制
0
输入 #4复制
20
VKKKKKKKKKVVVVVVVVVK
输出 #4复制
3
输入 #5复制
4
KVKV
输出 #5复制
1
说明/提示
对于 100\%100% 的数据，1\le n\le 1001≤n≤100。




这个题无非只有四种排列情况VK KV KK VV

其中，VK是符合要求的，KK和VV都能改一个字符成为VK，只有KV不可以改

先从头到尾跑一遍，把正确的VK都改为X

再跑一遍找到一个KK 或 VV就停


#include<stdio.h>
int main()
{
	char a[200];
	int n;
	scanf("%d %s", &n,a);
	int i = 0, sum = 0;
	for (i = 0; i < n-1; i++) {
		if (a[i] == 'V' && a[i + 1] == 'K') {
			a[i] = '1';
			a[i + 1] = '0';
			sum++;
		}
	}
	for (i = 0; i < n - 1; i++) {
		if (a[i] == a[i + 1]) {
			sum++;
			break;
		}
	}
	printf("%d", sum);
}