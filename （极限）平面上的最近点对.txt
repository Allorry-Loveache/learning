给定平面上 nn 个点，找出其中的一对点的距离，使得在这 nn 个点的所有点对中，该距离为所有点对中最小的

输入格式
第一行：nn ，保证2≤n≤200000 。

接下来 nn 行：每行两个实数：x y ，表示一个点的行坐标和列坐标，中间用一个空格隔开。

输出格式
仅一行，一个实数，表示最短距离，精确到小数点后面 4 位。

输入输出样例
输入 #1复制
3
1 1
1 2
2 2

输出 #1复制
1.0000



#define _CRT_SECURE_NO_WARNINGS
#include <iostream>  
#include <algorithm>  
#include<cmath>
using namespace std;
struct nums {
	int x;
	int y;
}a[200005];
bool cmp(nums a, nums b) {
	return (a.x == b.x) ? (a.y < b.y) : (a.x < b.x);
}
double dis(double a, double b, double c, double d) {
	return sqrt(abs(c - a) * abs(c - a) + abs(d - b) * abs(d - b));
}
int main()
{
	int n, i;
	double t, ans = 999999999;
	cin >> n;
	for (i = 0; i < n; i++)  scanf("%d %d", &a[i].x, &a[i].y);
	sort(a, a + n, cmp);
	for (int i = 2; i <= n; i++)ans = min(ans, dis(a[i].x, a[i].y, a[i - 1].x, a[i - 1].y));
	for (int i = 3; i <= n; i++)ans = min(ans, dis(a[i].x, a[i].y, a[i - 2].x, a[i - 2].y));
	for (int i = 4; i <= n; i++)ans = min(ans, dis(a[i].x, a[i].y, a[i - 3].x, a[i - 3].y));
	printf("%.4f", ans);
}
