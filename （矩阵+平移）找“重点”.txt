在一个N×N的矩阵中，如果某个元素的值大于其上下左右四个相邻元素之和，则本题称这个元素为“重点”。本题要求寻找给定矩阵中的所有“重点”。

需要注意的是：

矩阵中元素的坐标采用(x,y)的形式，x为元素所在的行号、y为元素所在的列号，x和y均从0开始
矩阵的行号由上至下增长；列号从左到右增长
最上方一行的元素，其“上方”相邻元素，位于同列的最下方一行
最下方一行的元素，其“下方”相邻元素，位于同列的最上方一行
最左方一列的元素，其“左方”相邻元素，位于同行的最右方一列
最右方一列的元素，其“右方”相邻元素，位于同行的最左方一列

输入样例1:
4
1 1 1 1
1 5 1 5
1 1 1 1
1 1 5 1
结尾无空行
输出样例1:   （行列坐标）
1 1
1 3
3 2



Code：
#include <stdio.h>
//int a[401][401];           //三目运算符做法
//int n, sum;
//int main()
//{
//	int flag = 0;
//	scanf("%d", &n);
//	for (int i = 1; i <= n; i++)
//	    for (int j = 1; j <= n; j++)
//		scanf("%d", &a[i][j]);
//	for (int i = 1; i <= n; i++)
//	    for (int j = 1; j <= n; j++){
//		int u = i == 1 ? n : i - 1;
//		int d = i == n ? 1 : i + 1;
//		int l = j == 1 ? n : j - 1;
//		int r = j == n ? 1 : j + 1;
//		sum += a[i][j];
//		if (a[i][j] > a[u][j] + a[d][j] + a[i][l] + a[i][r]){
//		    printf("%d %d\n", i - 1, j - 1);
//		    flag = 1;
//		}
//	    }
//	if (!flag) printf("None! %d\n", sum);
//	return 0;
//}

                  
#include <stdio.h>   //矩阵平移思想
int a[401][401];
int n, sum;
int main()
{
    int flag = 0;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
	for (int j = 1; j <= n; j++)
	    scanf("%d", &a[i][j]);
    for (int i = 1; i <= n; i++)
	for (int j = 1; j <= n; j++){			
	    sum += a[i][j];
	    if (a[i][j] > a[(i+n-2)%n+1][j] + a[(i+n+1)%n][j] + 
		a[i][(j+n+1)%n] + a[i][(j+n-2)%n+1])
	    {
		printf("%d %d\n", i - 1, j - 1);
                flag=1;
	    }
	}
    if (!flag) printf("None! %d\n", sum);
    return 0;
}
