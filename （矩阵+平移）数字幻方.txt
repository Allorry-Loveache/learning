幻方是一种很神奇的 N*NN∗N 矩阵：它由数字 1,2,3,\cdots \cdots ,N \times N1,2,3,⋯⋯,N×N 构成，且每行、每列及两条对角线上的数字之和都相同。

当 NN 为奇数时，我们可以通过下方法构建一个幻方：

首先将 11 写在第一行的中间。

之后，按如下方式从小到大依次填写每个数 K (K=2,3,\cdots,N \times N)K(K=2,3,⋯,N×N) ：

若 (K-1)(K−1) 在第一行但不在最后一列，则将 KK 填在最后一行， (K-1)(K−1) 所在列的右一列；
若 (K-1)(K−1) 在最后一列但不在第一行，则将 KK 填在第一列， (K-1)(K−1) 所在行的上一行；
若 (K-1)(K−1) 在第一行最后一列，则将 KK 填在 (K-1)(K−1) 的正下方；
若 (K-1)(K−1) 既不在第一行，也不在最后一列，如果 (K-1)(K−1) 的右上方还未填数，则将 KK 填在 (K-1)(K−1) 的右上方，否则将 KK 填在 (K-1)(K−1) 的正下方。
现给定 NN ，请按上述方法构造 N \times NN×N 的幻方。

输入格式
一个正整数 NN ，即幻方的大小。

输出格式
共 NN 行 ，每行 NN 个整数，即按上述方法构造出的 N \times NN×N 的幻方，相邻两个整数之间用单空格隔开。

输入输出样例
输入 #1复制
3
输出 #1复制
8 1 6
3 5 7
4 9 2





/*个人思考核心：最后一列和第一行是特殊的*/

// #include <stdio.h> 
// int a[39][39];
// int main()
// {
// 	int i, j, n;
// 	scanf("%d", &n);
// 	a[0][(n + 1) / 2 - 1] = 1;
// 	int x = 0, y = (n + 1) / 2 - 1;
// 	for (i = 2; i <= n*n; i++) {
// 		if (x == 0 && y == n - 1) {
// 			a[++x][y] = i;
// 		}
// 		else if (x == 0) {
// 			a[n - 1][++y] = i;
// 			x = n - 1;
// 		}
// 		else if (y == n-1) {
// 			a[--x][0] = i;
// 			y = 0;
// 		}
// 		else if (a[x - 1][y + 1] == 0)
// 			a[--x][++y] = i;
// 		else a[++x][y] = i;
// 	}
// 	for (i = 0; i < n; i++) {
// 		for (j = 0; j < n; j++)
// 			printf("%d ", a[i][j]);
// 		puts("");
// 	}
// }

/*最核心的点：只要数字右上边（逻辑右上）是空的，
              那就输进去，否则就放正下方（逻辑下）*/
#include <stdio.h> 
int a[40][40];
int main()
{
	int i, j, n;
	scanf("%d", &n);
	int x = 1, y = (n + 1) / 2;
	for (i = 1; i <= n*n; i++) {
		a[x][y] = i;
		if (!(a[(x - 2 + n) % n + 1][(y + n) % n + 1]))
			x = (x - 2 + n) % n + 1, y = y % n + 1;
		else x = x % n + 1;
	}
	for (i = 1; i <= n; i++) {
		for (j = 1; j <= n; j++)
			printf("%d ", a[i][j]);
		puts("");
	}
}