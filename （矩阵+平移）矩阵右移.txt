本题要求编写程序，将给定n×n方阵中的每个元素循环向右移m个位置，
即将第0、1、⋯、n−1列变换为第n−m、n−m+1、⋯、n−1、0、1、⋯、n−m−1列。

输入格式：
输入第一行给出两个正整数m和n（1≤n≤6）。接下来一共n行，
每行n个整数，表示一个n阶的方阵。

输出格式：
按照输入格式输出移动后的方阵：即输出n行，每行n个整数，每个整数后输出一个空格。

输入样例：
2 3
1 2 3
4 5 6
7 8 9
结尾无空行
输出样例：
2 3 1 
5 6 4 
8 9 7 


Code：
#include<stdio.h>
int main(){
    int i,n,m,j,a[15][15];
    scanf("%d %d",&m,&n);
    for(i=0;i<n;i++)
       for(j=0;j<n;j++)
	   scanf("%d",&a[i][j]);   
    m%=n;       //比如平移5个单位，对于3长度
                //矩阵，相当于平移2次
    for(i=0;i<n;i++){
    	for(j=0;j<n;j++)
      //反推法，比正着推要简单很多
      //这里仅为了打印，不需要多定义b数组
    	    printf("%d ",a[i][(j+n-m)%n]);
        printf("\n");	
    }	
}

//正推法code:
//#include<stdio.h>
//int a[15][15], b[15][15];
//int main() 
//{
//    int i, n, m, j;
//    scanf("%d %d", &m, &n);
//    for (i = 1; i <= n; i++)
//	  for (j = 1; j <= n; j++)
//	      scanf("%d", &a[i][j]);
//    m %= n;
//    for (i = 1; i <= n; i++)
//	  for (j = 1; j <= n; j++)
//	      b[i][(j + m -1) % n+1] = a[i][j];
//    for (i = 1; i <= n; i++) {
//	  for (j = 1; j <= n; j++)
//	      printf("%d ", b[i][j]);
//	  puts("");
//    }
//}
